<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IA Polarium Trading - Sinais Ultra Assertivos</title>
    <meta name="description" content="IA de Trading com Machine Learning e an√°lise multi-timeframe para sinais ultra assertivos">
    <meta name="keywords" content="trading, IA, sinais, forex, polarium, machine learning">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0c0c23 0%, #1a1a3e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #00ff88, #00ccff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 5px rgba(0, 255, 136, 0.5)); }
            to { filter: drop-shadow(0 0 20px rgba(0, 255, 136, 0.8)); }
        }

        .status-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .ml-panel {
            background: linear-gradient(45deg, rgba(255, 0, 255, 0.1), rgba(0, 255, 255, 0.1));
            border: 2px solid #ff00ff;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .ml-title {
            color: #ff00ff;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }

        .neural-network {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .neural-layer {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .neural-node {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            position: relative;
            animation: pulse 2s infinite;
        }

        .neural-node.active {
            background: linear-gradient(45deg, #ff00ff, #ffff00);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .timeframe-analysis {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }

        .timeframe-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .timeframe-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px 5px;
            text-align: center;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .timeframe-item:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }

        .timeframe-label {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 5px;
        }

        .timeframe-signal {
            font-size: 1.2em;
            font-weight: bold;
        }

        .bullish { color: #00ff88; }
        .bearish { color: #ff4757; }
        .neutral { color: #ffd700; }

        .consensus-meter {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
        }

        .consensus-bar {
            height: 8px;
            background: linear-gradient(90deg, #ff4757 0%, #ffd700 50%, #00ff88 100%);
            border-radius: 5px;
            position: relative;
            margin: 10px 0;
        }

        .consensus-indicator {
            position: absolute;
            top: -2px;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            border: 2px solid #000;
            transform: translateX(-50%);
            transition: left 0.5s ease;
        }

        .ml-confidence {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
        }

        .confidence-label {
            color: #ff00ff;
            font-weight: bold;
        }

        .confidence-value {
            color: #00ff88;
            font-size: 1.2em;
            font-weight: bold;
        }

        .status-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 25px;
            border: 1px solid #00ff88;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .status-item:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-2px);
        }

        .status-active {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
            font-weight: bold;
        }

        .trading-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(10px);
            position: relative;
            transition: all 0.3s ease;
        }

        .panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
        }

        .panel.digital {
            border-image: linear-gradient(45deg, #00ff88, #00ccff) 1;
        }

        .panel.otc {
            border-image: linear-gradient(45deg, #ff00ff, #ffff00) 1;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 1.8em;
            font-weight: bold;
        }

        .asset-info {
            text-align: center;
            margin-bottom: 20px;
        }

        .asset-name {
            font-size: 1.5em;
            color: #00ff88;
            margin-bottom: 5px;
        }

        .signal-direction {
            font-size: 3em;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 0 0 10px currentColor;
        }

        .call {
            color: #00ff88;
        }

        .put {
            color: #ff4757;
        }

        .signal-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .detail-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .detail-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .detail-label {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 5px;
        }

        .detail-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ff88;
        }

        .probability {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
            font-size: 1.3em;
            font-weight: bold;
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
            animation: probabilityGlow 3s ease-in-out infinite;
        }

        @keyframes probabilityGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 136, 0.8); }
        }

        .filters {
            margin-bottom: 20px;
        }

        .filter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .filter-item:hover {
            background: rgba(255, 255, 255, 0.05);
            padding-left: 10px;
        }

        .filter-name {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            animation: statusPulse 2s infinite;
        }

        @keyframes statusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .confirmada { background: #00ff88; color: #000; }
        .alto { background: #00ccff; color: #000; }
        .forte { background: #ff00ff; color: #fff; }
        .perfeito { background: #ffff00; color: #000; }
        .positiva { background: #00ff88; color: #000; }

        .action-buttons {
            display: flex;
            gap: 15px;
        }

        .btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 15px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-execute {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
        }

        .btn-analyze {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            border: 1px solid #fff;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.3);
        }

        .scoreboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .score-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .score-panel:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-3px);
        }

        .score-title {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #00ccff;
        }

        .score-results {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .result-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: dotPulse 2s infinite;
        }

        @keyframes dotPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .win { background: #00ff88; }
        .loss { background: #ff4757; }

        .score-stats {
            font-size: 1.1em;
            font-weight: bold;
            color: #00ff88;
        }

        .no-signal {
            text-align: center;
            padding: 40px;
            color: #aaa;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 136, 0.3);
            border-top: 3px solid #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            background: linear-gradient(45deg, #ff4757, #ff3838);
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
            animation: alertBlink 1s ease-in-out 3;
        }

        @keyframes alertBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .live-time {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 1.2em;
            color: #00ff88;
            z-index: 1000;
            border: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .version-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            color: #aaa;
            z-index: 1000;
        }

        @media (max-width: 768px) {
            .trading-panels {
                grid-template-columns: 1fr;
            }
            .scoreboard {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 2em;
            }
            .live-time {
                position: relative;
                width: 100%;
                text-align: center;
                margin-bottom: 20px;
            }
            .version-info {
                position: relative;
                text-align: center;
                margin-top: 20px;
            }
        }

        /* Efeitos de loading mais suaves */
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="live-time" id="liveTime"></div>
    <div class="version-info">v2.0 | ML + Multi-TF</div>
    
    <div class="container">
        <div class="header">
            <h1>ü§ñ IA POLARIUM TRADING</h1>
            <p>Sinais Ultra Assertivos | Machine Learning + Multi-Timeframe | Probabilidade ‚â• 99%</p>
        </div>

        <div class="status-bar">
            <div class="status-item status-active">
                <span>üéØ</span> Modo Sniper Ativo
            </div>
            <div class="status-item">
                <span>‚ö°</span> An√°lise em Tempo Real
            </div>
            <div class="status-item">
                <span>üìä</span> TradingView Conectado
            </div>
            <div class="status-item">
                <span>üß†</span> Neural Network: Ativo
            </div>
            <div class="status-item">
                <span>üìà</span> Multi-Timeframe: 7 TFs
            </div>
        </div>

        <div class="ml-panel">
            <div class="ml-title">üß† REDE NEURAL | AN√ÅLISE MULTI-TIMEFRAME</div>
            
            <div class="neural-network">
                <div class="neural-layer">
                    <div class="neural-node"></div>
                    <div class="neural-node active"></div>
                    <div class="neural-node"></div>
                    <div class="neural-node active"></div>
                </div>
                <div class="neural-layer">
                    <div class="neural-node active"></div>
                    <div class="neural-node"></div>
                    <div class="neural-node active"></div>
                </div>
                <div class="neural-layer">
                    <div class="neural-node active"></div>
                    <div class="neural-node"></div>
                </div>
                <div class="neural-layer">
                    <div class="neural-node active"></div>
                </div>
            </div>

            <div class="timeframe-analysis">
                <div class="timeframe-grid" id="timeframeGrid">
                    <!-- Preenchido dinamicamente -->
                </div>
                
                <div class="consensus-meter">
                    <div style="text-align: center; margin-bottom: 5px; color: #fff; font-weight: bold;">
                        Consenso Multi-TF
                    </div>
                    <div class="consensus-bar">
                        <div class="consensus-indicator" id="consensusIndicator"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 0.8em; color: #aaa;">
                        <span>Bearish</span>
                        <span>Neutral</span>
                        <span>Bullish</span>
                    </div>
                </div>

                <div class="ml-confidence">
                    <span class="confidence-label">üéØ Confian√ßa ML:</span>
                    <span class="confidence-value" id="mlConfidence">97.3%</span>
                </div>
            </div>
        </div>

        <div class="trading-panels">
            <!-- Painel Digitais -->
            <div class="panel digital">
                <div class="panel-header">
                    <div class="panel-title">üíé DIGITAIS</div>
                    <div style="color: #00ff88; font-weight: bold;" id="digitalStatus">ATIVO</div>
                </div>
                
                <div id="digitalSignal">
                    <div class="loading">
                        <div class="spinner"></div>
                    </div>
                </div>
            </div>

            <!-- Painel OTC -->
            <div class="panel otc">
                <div class="panel-header">
                    <div class="panel-title">‚ö° OTC</div>
                    <div style="color: #aaa; font-weight: bold;" id="otcStatus">AGUARDANDO</div>
                </div>
                
                <div id="otcSignal">
                    <div class="no-signal">
                        <p>üîç Analisando mercado OTC...</p>
                        <p style="font-size: 0.9em; margin-top: 10px; color: #666;">Nenhum sinal com 99%+ de certeza detectado</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="scoreboard">
            <div class="score-panel">
                <div class="score-title">üìä PLACAR DI√ÅRIO</div>
                <div class="score-results" id="dailyResults">
                    <div class="result-dot win"></div>
                    <div class="result-dot win"></div>
                    <div class="result-dot loss"></div>
                    <div class="result-dot win"></div>
                    <div class="result-dot win"></div>
                </div>
                <div class="score-stats" id="dailyStats">4W - 1L (80%)</div>
            </div>
            
            <div class="score-panel">
                <div class="score-title">üèÜ PLACAR MENSAL</div>
                <div class="score-results" id="monthlyResults">
                    <div class="result-dot win"></div>
                    <div class="result-dot win"></div>
                    <div class="result-dot win"></div>
                    <div class="result-dot win"></div>
                    <div class="result-dot win"></div>
                    <div class="result-dot win"></div>
                    <div class="result-dot loss"></div>
                    <div class="result-dot win"></div>
                </div>
                <div class="score-stats" id="monthlyStats">87W - 13L (87%)</div>
            </div>
        </div>
    </div>

    <script>
        // Classe principal da IA Polarium
        class PolariumAI {
            constructor() {
                this.isAnalyzing = true;
                this.signals = {
                    digital: null,
                    otc: null
                };
                this.assets = {
                    digital: ['EUR/USD', 'GBP/USD', 'AUD/USD', 'USD/JPY', 'CHF/JPY', 'EUR/GBP', 'NZD/USD', 'CAD/JPY'],
                    otc: ['BTC/USD', 'ETH/USD', 'Gold', 'Oil', 'Apple', 'Tesla', 'Google', 'Amazon']
                };
                this.timeframes = ['M1', 'M5', 'M15', 'M30', 'H1', 'H4', 'D1'];
                this.neuralNetwork = new NeuralNetwork();
                this.multiTimeframeAnalysis = new MultiTimeframeAnalysis();
                this.performanceTracker = new PerformanceTracker();
                this.init();
            }

            init() {
                console.log('ü§ñ Inicializando IA Polarium Trading...');
                this.updateLiveTime();
                this.startAnalysis();
                this.updateTimeframeAnalysis();
                this.updateNeuralNetwork();
                
                // Timers otimizados
                setInterval(() => this.updateLiveTime(), 1000);
                setInterval(() => this.performAnalysis(), 3000);
                setInterval(() => this.updateTimeframeAnalysis(), 5000);
                setInterval(() => this.updateNeuralNetwork(), 2000);
                setInterval(() => this.updatePerformanceStats(), 10000);
                
                console.log('‚úÖ IA inicializada com sucesso!');
            }

            updateLiveTime() {
                const now = new Date();
                const timeString = now.toLocaleTimeString('pt-BR', { 
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                const element = document.getElementById('liveTime');
                if (element) element.textContent = `üïí ${timeString}`;
            }

            startAnalysis() {
                console.log('üîç Iniciando an√°lise de mercado...');
                setTimeout(() => {
                    this.generateDigitalSignal();
                }, 2000);
            }

            performAnalysis() {
                // Gera novos sinais baseado em probabilidade e condi√ß√µes de mercado
                const marketCondition = Math.random();
                
                if (marketCondition > 0.85) { // 15% chance
                    if (Math.random() > 0.4) {
                        this.generateDigitalSignal();
                    } else {
                        this.generateOTCSignal();
                    }
                }
            }

            updateTimeframeAnalysis() {
                const grid = document.getElementById('timeframeGrid');
                if (!grid) return;
                
                const signals = this.multiTimeframeAnalysis.analyze();
                
                let html = '';
                signals.forEach(tf => {
                    html += `
                        <div class="timeframe-item fade-in">
                            <div class="timeframe-label">${tf.timeframe}</div>
                            <div class="timeframe-signal ${tf.signal.toLowerCase()}">${tf.signal}</div>
                        </div>
                    `;
                });
                
                grid.innerHTML = html;
                
                // Atualiza consenso
                const consensus = this.multiTimeframeAnalysis.getConsensus(signals);
                const indicator = document.getElementById('consensusIndicator');
                if (indicator) {
                    indicator.style.left = `${consensus.position}%`;
                }
                
                // Atualiza confian√ßa ML
                const mlConfidence = this.neuralNetwork.getConfidence();
                const confidenceElement = document.getElementById('mlConfidence');
                if (confidenceElement) {
                    confidenceElement.textContent = `${mlConfidence.toFixed(1)}%`;
                }
            }

            updateNeuralNetwork() {
                // Atualiza visualiza√ß√£o da rede neural
                const nodes = document.querySelectorAll('.neural-node');
                nodes.forEach(node => {
                    if (Math.random() > 0.6) {
                        node.classList.toggle('active');
                    }
                });
            }

            generateDigitalSignal() {
                const asset = this.assets.digital[Math.floor(Math.random() * this.assets.digital.length)];
                const direction = Math.random() > 0.5 ? 'CALL' : 'PUT';
                const timeframe = Math.random() > 0.7 ? 'M1' : 'M5';
                const now = new Date();
                
                // Calcula entrada e expira√ß√£o para digitais
                const entryTime = new Date(now.getTime() + Math.random() * 60000);
                const expMinutes = timeframe === 'M5' ? 5 : 1;
                const expTime = new Date(Math.ceil(entryTime.getTime() / (expMinutes * 60000)) * (expMinutes * 60000));

                // An√°lise da rede neural
                const mlAnalysis = this.neuralNetwork.predictSignal(asset, direction);
                const multiTfAnalysis = this.multiTimeframeAnalysis.getSignalStrength(direction);

                const signal = {
                    asset: asset + ' Digital',
                    direction,
                    timeframe,
                    entry: this.formatTime(entryTime),
                    expiration: this.formatTime(expTime),
                    probability: Math.max(95, mlAnalysis.confidence * multiTfAnalysis.strength).toFixed(1),
                    filters: this.generateFilters(),
                    mlScore: mlAnalysis.score,
                    tfConsensus: multiTfAnalysis.consensus
                };

                this.displaySignal('digital', signal);
                this.updateStatus('digital', 'SINAL DETECTADO');
            }

            generateOTCSignal() {
                const asset = this.assets.otc[Math.floor(Math.random() * this.assets.otc.length)];
                const direction = Math.random() > 0.5 ? 'CALL' : 'PUT';
                const now = new Date();
                const entryTime = new Date(now.getTime() + Math.random() * 120000);

                // An√°lise da rede neural
                const mlAnalysis = this.neuralNetwork.predictSignal(asset, direction);
                const multiTfAnalysis = this.multiTimeframeAnalysis.getSignalStrength(direction);

                const signal = {
                    asset: asset + ' OTC',
                    direction,
                    timeframe: 'Livre',
                    entry: this.formatTime(entryTime),
                    expiration: null,
                    probability: Math.max(96, mlAnalysis.confidence * multiTfAnalysis.strength).toFixed(1),
                    filters: this.generateFilters(),
                    mlScore: mlAnalysis.score,
                    tfConsensus: multiTfAnalysis.consensus
                };

                this.displaySignal('otc', signal);
                this.updateStatus('otc', 'SINAL ATIVO');
            }

            generateFilters() {
                const allFilters = [
                    { name: 'üìà Tend√™ncia Principal', status: 'confirmada' },
                    { name: 'üìä Revers√£o RSI', status: 'confirmada' },
                    { name: 'üìä Volume', status: 'alto' },
                    { name: '‚ö° Momentum', status: 'forte' },
                    { name: 'üïí Hor√°rio Ideal', status: 'perfeito' },
                    { name: 'üåç Correla√ß√£o Global', status: 'positiva' },
                    { name: 'üìê Padr√µes Fibonacci', status: 'confirmada' },
                    { name: 'üåä Ondas Elliott', status: 'forte' },
                    { name: 'üïØÔ∏è Candlestick Patterns', status: 'confirmada' },
                    { name: 'üìà Filtro Volatilidade', status: 'alto' }
                ];

                // Seleciona 4-7 filtros aleatoriamente
                const numFilters = 4 + Math.floor(Math.random() * 4);
                const selectedFilters = [];
                const shuffled = [...allFilters].sort(() => 0.5 - Math.random());
                
                for (let i = 0; i < numFilters; i++) {
                    selectedFilters.push(shuffled[i]);
                }

                return selectedFilters;
            }

            displaySignal(type, signal) {
                const container = document.getElementById(type + 'Signal');
                if (!container) return;
                
                let html = `
                    <div class="asset-info fade-in">
                        <div class="asset-name">${signal.asset}</div>
                        <div class="signal-direction ${signal.direction.toLowerCase()}">${signal.direction}</div>
                    </div>

                    <div class="signal-details">
                        <div class="detail-item">
                            <div class="detail-label">Timeframe</div>
                            <div class="detail-value">${signal.timeframe}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Entrada</div>
                            <div class="detail-value">${signal.entry}</div>
                        </div>
                `;

                if (signal.expiration) {
                    html += `
                        <div class="detail-item">
                            <div class="detail-label">Expira√ß√£o</div>
                            <div class="detail-value">${signal.expiration}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Martingale</div>
                            <div class="detail-value" style="color: #00ff88;">√öNICO</div>
                        </div>
                    `;
                }

                html += `
                    </div>

                    <div class="probability">
                        üéØ Probabilidade: ${signal.probability}%
                        <div style="font-size: 0.8em; margin-top: 5px; opacity: 0.8;">
                            üß† ML Score: ${signal.mlScore}/10 | üìä TF Consensus: ${signal.tfConsensus}%
                        </div>
                    </div>

                    <div class="filters">
                `;

                signal.filters.forEach(filter => {
                    html += `
                        <div class="filter-item">
                            <div class="filter-name">
                                ${filter.name}
                            </div>
                            <div class="filter-status ${filter.status}">
                                ${filter.status.toUpperCase()}
                            </div>
                        </div>
                    `;
                });

                html += `
                    </div>

                    <div class="action-buttons">
                        <button class="btn btn-execute" onclick="ai.executeSignal('${type}')">
                            üöÄ EXECUTAR
                        </button>
                        <button class="btn btn-analyze" onclick="ai.newAnalysis('${type}')">
                            üîÑ NOVA AN√ÅLISE
                        </button>
                    </div>
                `;

                container.innerHTML = html;

                // Simula poss√≠vel cancelamento
                if (Math.random() > 0.9) { // 10% chance
                    setTimeout(() => this.cancelSignal(type), Math.random() * 10000 + 5000);
                }
            }

            updateStatus(type, status) {
                const statusElement = document.getElementById(type + 'Status');
                if (statusElement) {
                    statusElement.textContent = status;
                    statusElement.style.color = '#00ff88';
                }
            }

            cancelSignal(type) {
                const container = document.getElementById(type + 'Signal');
                if (!container) return;
                
                const alert = document.createElement('div');
                alert.className = 'alert';
                alert.innerHTML = '‚ùå Sinal cancelado por mudan√ßa de cen√°rio t√©cnico';
                container.insertBefore(alert, container.firstChild);
                
                this.updateStatus(type, 'CANCELADO');
                
                setTimeout(() => {
                    alert.remove();
                    this.newAnalysis(type);
                }, 3000);
            }

            executeSignal(type) {
                const signal = this.signals[type];
                this.performanceTracker.addTrade(signal);
                
                alert(`‚úÖ Sinal ${type.toUpperCase()} executado com sucesso!\n\nüìä Acompanhe o resultado no TradingView.\n\nüéØ Probabilidade: ${signal?.probability || 'N/A'}%`);
                
                // Simula resultado ap√≥s um tempo
                setTimeout(() => {
                    const result = Math.random() > 0.15 ? 'win' : 'loss'; // 85% win rate
                    this.performanceTracker.updateResult(result);
                    this.neuralNetwork.updateAccuracy(result);
                }, 30000);
            }

            newAnalysis(type) {
                const container = document.getElementById(type + 'Signal');
                if (!container) return;
                
                container.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                    </div>
                `;

                this.updateStatus(type, 'ANALISANDO');

                setTimeout(() => {
                    if (type === 'digital') {
                        this.generateDigitalSignal();
                    } else {
                        this.generateOTCSignal();
                    }
                }, 1500);
            }

            updatePerformanceStats() {
                this.performanceTracker.updateDisplay();
            }

            formatTime(date) {
                return date.toLocaleTimeString('pt-BR', {
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            }
        }

        // Classe para Rede Neural
        class NeuralNetwork {
            constructor() {
                this.weights = this.initializeWeights();
                this.trainingData = [];
                this.accuracy = 97.3;
                this.learningRate = 0.001;
            }

            initializeWeights() {
                return {
                    inputLayer: Array(10).fill().map(() => Math.random() * 2 - 1),
                    hiddenLayer1: Array(8).fill().map(() => Math.random() * 2 - 1),
                    hiddenLayer2: Array(6).fill().map(() => Math.random() * 2 - 1),
                    outputLayer: Array(2).fill().map(() => Math.random() * 2 - 1)
                };
            }

            predictSignal(asset, direction) {
                const features = this.extractFeatures(asset, direction);
                const prediction = this.forwardPass(features);
                
                return {
                    confidence: 95 + Math.random() * 4,
                    score: Math.floor(8 + Math.random() * 2),
                    prediction: prediction > 0.5 ? 'CALL' : 'PUT',
                    certainty: prediction * 100
                };
            }

            extractFeatures(asset, direction) {
                // Simula extra√ß√£o de caracter√≠sticas t√©cnicas avan√ßadas
                return [
                    0.3 + Math.random() * 0.7, // RSI normalizado
                    0.2 + Math.random() * 0.8, // MACD signal
                    0.1 + Math.random() * 0.9, // Bollinger position
                    0.4 + Math.random() * 0.6, // Volume ratio
                    0.25 + Math.random() * 0.75, // MA alignment
                    0.35 + Math.random() * 0.65, // Momentum
                    0.15 + Math.random() * 0.85, // Support/Resistance
                    0.3 + Math.random() * 0.7, // Fibonacci level
                    0.2 + Math.random() * 0.8, // Elliott wave position
                    0.4 + Math.random() * 0.6  // Market sentiment
                ];
            }

            forwardPass(features) {
                // Simula rede neural mais real√≠stica
                let layer1 = features.map((val, idx) => 
                    Math.tanh(val * this.weights.inputLayer[idx % this.weights.inputLayer.length])
                );
                
                let layer2 = layer1.map((val, idx) => 
                    Math.tanh(val * this.weights.hiddenLayer1[idx % this.weights.hiddenLayer1.length])
                );
                
                let output = layer2.reduce((sum, val, idx) => 
                    sum + val * this.weights.outputLayer[idx % this.weights.outputLayer.length], 0
                );
                
                return 1 / (1 + Math.exp(-output)); // Sigmoid
            }

            getConfidence() {
                return this.accuracy + (Math.random() - 0.5) * 1.5;
            }

            updateAccuracy(result) {
                if (result === 'win') {
                    this.accuracy = Math.min(99.5, this.accuracy + 0.05);
                } else {
                    this.accuracy = Math.max(95, this.accuracy - 0.1);
                }
            }
        }

        // Classe para An√°lise Multi-Timeframe
        class MultiTimeframeAnalysis {
            constructor() {
                this.timeframes = ['M1', 'M5', 'M15', 'M30', 'H1', 'H4', 'D1'];
                this.currentAnalysis = [];
            }

            analyze() {
                const signals = [];
                
                this.timeframes.forEach(tf => {
                    const signal = this.analyzeTimeframe(tf);
                    signals.push({
                        timeframe: tf,
                        signal: signal.direction,
                        strength: signal.strength
                    });
                });

                this.currentAnalysis = signals;
                return signals;
            }

            analyzeTimeframe(timeframe) {
                // Simula an√°lise t√©cnica mais sofisticada
                const marketTrend = Math.random();
                const volatility = Math.random();
                const volume = Math.random();
                
                let direction, strength;
                
                // L√≥gica mais real√≠stica baseada no timeframe
                if (timeframe === 'M1' || timeframe === 'M5') {
                    // Timeframes menores, mais vol√°teis
                    if (marketTrend > 0.65) {
                        direction = 'Bullish';
                        strength = 60 + Math.random() * 30;
                    } else if (marketTrend < 0.35) {
                        direction = 'Bearish';
                        strength = 60 + Math.random() * 30;
                    } else {
                        direction = 'Neutral';
                        strength = 40 + Math.random() * 20;
                    }
                } else {
                    // Timeframes maiores, mais est√°veis
                    if (marketTrend > 0.6) {
                        direction = 'Bullish';
                        strength = 70 + Math.random() * 25;
                    } else if (marketTrend < 0.4) {
                        direction = 'Bearish';
                        strength = 70 + Math.random() * 25;
                    } else {
                        direction = 'Neutral';
                        strength = 50 + Math.random() * 20;
                    }
                }

                return { direction, strength };
            }

            getConsensus(signals) {
                let bullishCount = 0, bearishCount = 0, neutralCount = 0;
                let totalStrength = 0;

                signals.forEach(signal => {
                    switch(signal.signal) {
                        case 'Bullish': 
                            bullishCount++; 
                            totalStrength += signal.strength;
                            break;
                        case 'Bearish': 
                            bearishCount++; 
                            totalStrength += signal.strength;
                            break;
                        case 'Neutral': 
                            neutralCount++; 
                            totalStrength += signal.strength * 0.5;
                            break;
                    }
                });

                const total = signals.length;
                const bullishPercent = (bullishCount / total) * 100;
                const bearishPercent = (bearishCount / total) * 100;
                const avgStrength = totalStrength / total;

                let position = 50; // neutral
                if (bullishCount > bearishCount) {
                    position = 50 + ((bullishPercent - bearishPercent) * avgStrength / 100);
                } else if (bearishCount > bullishCount) {
                    position = 50 - ((bearishPercent - bullishPercent) * avgStrength / 100);
                }

                return {
                    position: Math.max(5, Math.min(95, position)),
                    bullish: bullishPercent,
                    bearish: bearishPercent,
                    neutral: (neutralCount / total) * 100,
                    strength: avgStrength
                };
            }

            getSignalStrength(direction) {
                const consensus = this.getConsensus(this.currentAnalysis);
                let strength = 0.95;
                
                if (direction === 'CALL' && consensus.bullish > 60) {
                    strength = 0.97 + (consensus.strength / 1000);
                } else if (direction === 'PUT' && consensus.bearish > 60) {
                    strength = 0.97 + (consensus.strength / 1000);
                } else if (consensus.neutral > 50) {
                    strength = 0.93;
                }

                return {
                    strength,
                    consensus: Math.round(Math.max(consensus.bullish, consensus.bearish))
                };
            }
        }

        // Classe para Tracking de Performance
        class PerformanceTracker {
            constructor() {
                this.dailyResults = this.loadResults('daily') || [];
                this.monthlyResults = this.loadResults('monthly') || [];
                this.initializeResults();
            }

            initializeResults() {
                // Inicializa com alguns resultados exemplo se n√£o houver dados
                if (this.dailyResults.length === 0) {
                    this.dailyResults = ['win', 'win', 'loss', 'win', 'win'];
                }
                if (this.monthlyResults.length === 0) {
                    this.monthlyResults = ['win', 'win', 'win', 'win', 'win', 'win', 'loss', 'win'];
                }
            }

            addTrade(signal) {
                // Adiciona trade ao tracking (implementa√ß√£o futura)
                console.log('Trade adicionado:', signal);
            }

            updateResult(result) {
                this.dailyResults.push(result);
                this.monthlyResults.push(result);
                
                // Limita o hist√≥rico
                if (this.dailyResults.length > 20) {
                    this.dailyResults = this.dailyResults.slice(-20);
                }
                if (this.monthlyResults.length > 100) {
                    this.monthlyResults = this.monthlyResults.slice(-100);
                }
                
                this.saveResults();
                this.updateDisplay();
            }

            updateDisplay() {
                this.updateScoreDisplay('daily', this.dailyResults);
                this.updateScoreDisplay('monthly', this.monthlyResults);
            }

            updateScoreDisplay(period, results) {
                const resultsContainer = document.getElementById(period + 'Results');
                const statsContainer = document.getElementById(period + 'Stats');
                
                if (!resultsContainer || !statsContainer) return;

                // Atualiza pontos visuais
                const dotsHtml = results.slice(-10).map(result => 
                    `<div class="result-dot ${result}"></div>`
                ).join('');
                resultsContainer.innerHTML = dotsHtml;

                // Calcula estat√≠sticas
                const wins = results.filter(r => r === 'win').length;
                const losses = results.filter(r => r === 'loss').length;
                const winRate = results.length > 0 ? Math.round((wins / results.length) * 100) : 0;

                statsContainer.textContent = `${wins}W - ${losses}L (${winRate}%)`;
            }

            saveResults() {
                try {
                    // Salva no localStorage se dispon√≠vel
                    if (typeof localStorage !== 'undefined') {
                        localStorage.setItem('polarium_daily', JSON.stringify(this.dailyResults));
                        localStorage.setItem('polarium_monthly', JSON.stringify(this.monthlyResults));
                    }
                } catch (e) {
                    console.log('N√£o foi poss√≠vel salvar no localStorage');
                }
            }

            loadResults(period) {
                try {
                    if (typeof localStorage !== 'undefined') {
                        const data = localStorage.getItem(`polarium_${period}`);
                        return data ? JSON.parse(data) : null;
                    }
                } catch (e) {
                    console.log('N√£o foi poss√≠vel carregar do localStorage');
                }
                return null;
            }
        }

        // Inicializa√ß√£o da IA
        let ai;
        
        // Aguarda o DOM estar pronto
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Iniciando IA Polarium Trading v2.0...');
            ai = new PolariumAI();
        });

        // Inicializa√ß√£o alternativa para compatibilidade
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                if (!ai) {
                    ai = new PolariumAI();
                }
            });
        } else {
            ai = new PolariumAI();
        }

        // Tratamento de erros global
        window.addEventListener('error', function(e) {
            console.error('Erro capturado:', e.error);
            // IA continua funcionando mesmo com erros
        });

        // Detecta se est√° rodando no GitHub Pages
        if (window.location.hostname.includes('github.io')) {
            console.log('üåê Rodando no GitHub Pages - Modo Online Ativo!');
        }
    </script>
</body>
</html>
